name: Update Template

on:
  workflow_call:
    inputs:
      template_id:
        description: "The template ID to update"
        required: true
        type: string
      api_base_url:
        description: "Base URL for the API"
        required: true
        type: string
    secrets:
      api_bearer_token:
        description: "Bearer token for API authentication"
        required: true

jobs:
  update-template:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Validate template config exists
        run: |
          if [ ! -f "template-config.json" ]; then
            echo "template-config.json not found!"
            exit 1
          fi
          
          # Validate JSON syntax
          if ! jq empty template-config.json; then
            echo "template-config.json is not valid JSON!"
            exit 1
          fi
          
          echo "âœ… template-config.json found and is valid JSON"
      
      - name: Extract config values
        id: extract-values
        run: |
          # Extract values directly from the template-config.json file
          NAME=$(jq -r '.name // ""' template-config.json)
          SHORT_DESC=$(jq -r '.short_description // ""' template-config.json)
          EGG_FEATURE=$(jq -r '.egg_feature // ""' template-config.json)
          CREATE_DB=$(jq -r '.create_database // false' template-config.json)
          IS_ACTIVE=$(jq -r '.is_active // false' template-config.json)
          AUTHOR=$(jq -r '.author // ""' template-config.json)
          ICON_URL=$(jq -r '.icon_url // ""' template-config.json)
          VIDEO_URL=$(jq -r '.video_url // ""' template-config.json)
          
          # Always use the actual repository and branch from the workflow context
          GITHUB_REPO="${{ github.repository }}"
          GITHUB_BRANCH="${{ github.ref_name }}"
          
          # Use proper escaping for multiline output
          echo "name<<EOF" >> $GITHUB_OUTPUT
          echo "$NAME" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "short_description<<EOF" >> $GITHUB_OUTPUT
          echo "$SHORT_DESC" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "egg_feature<<EOF" >> $GITHUB_OUTPUT
          echo "$EGG_FEATURE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "create_database=$CREATE_DB" >> $GITHUB_OUTPUT
          echo "is_active=$IS_ACTIVE" >> $GITHUB_OUTPUT
          
          echo "author_name<<EOF" >> $GITHUB_OUTPUT
          echo "$AUTHOR" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "icon_url<<EOF" >> $GITHUB_OUTPUT
          echo "$ICON_URL" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "video_url<<EOF" >> $GITHUB_OUTPUT
          echo "$VIDEO_URL" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "github_repository=$GITHUB_REPO" >> $GITHUB_OUTPUT
          echo "github_branch=$GITHUB_BRANCH" >> $GITHUB_OUTPUT
      
      - name: Create API payload
        run: |
          # Extract variables directly from template-config.json to avoid any shell escaping issues
          jq -c '.variables // []' template-config.json > variables.json
          
          # Extract required_files directly from template-config.json (empty array if not present)
          jq -c '.required_files // []' template-config.json > required_files.json
          
          # Handle README content safely - use empty string if no README
          if [ -f "README.md" ]; then
            # README exists, use it
            jq -n \
              --arg name "${{ steps.extract-values.outputs.name }}" \
              --arg short_description "${{ steps.extract-values.outputs.short_description }}" \
              --rawfile long_description "README.md" \
              --arg egg_feature "${{ steps.extract-values.outputs.egg_feature }}" \
              --argjson create_database "${{ steps.extract-values.outputs.create_database }}" \
              --argjson is_active "${{ steps.extract-values.outputs.is_active }}" \
              --arg author_name "${{ steps.extract-values.outputs.author_name }}" \
              --arg icon_url "${{ steps.extract-values.outputs.icon_url }}" \
              --arg video_url "${{ steps.extract-values.outputs.video_url }}" \
              --arg github_repository "${{ steps.extract-values.outputs.github_repository }}" \
              --arg github_branch "${{ steps.extract-values.outputs.github_branch }}" \
              --slurpfile variables variables.json \
              --slurpfile required_files required_files.json \
              '{
                name: $name,
                short_description: $short_description,
                long_description: $long_description,
                egg_feature: $egg_feature,
                create_database: $create_database,
                is_active: $is_active,
                author_name: $author_name,
                icon_url: $icon_url,
                video_url: $video_url,
                github_repository: $github_repository,
                github_branch: $github_branch,
                variables: $variables[0],
                required_files: $required_files[0]
              }' > payload.json
          else
            # No README, use empty string
            jq -n \
              --arg name "${{ steps.extract-values.outputs.name }}" \
              --arg short_description "${{ steps.extract-values.outputs.short_description }}" \
              --arg long_description "" \
              --arg egg_feature "${{ steps.extract-values.outputs.egg_feature }}" \
              --argjson create_database "${{ steps.extract-values.outputs.create_database }}" \
              --argjson is_active "${{ steps.extract-values.outputs.is_active }}" \
              --arg author_name "${{ steps.extract-values.outputs.author_name }}" \
              --arg icon_url "${{ steps.extract-values.outputs.icon_url }}" \
              --arg video_url "${{ steps.extract-values.outputs.video_url }}" \
              --arg github_repository "${{ steps.extract-values.outputs.github_repository }}" \
              --arg github_branch "${{ steps.extract-values.outputs.github_branch }}" \
              --slurpfile variables variables.json \
              --slurpfile required_files required_files.json \
              '{
                name: $name,
                short_description: $short_description,
                long_description: $long_description,
                egg_feature: $egg_feature,
                create_database: $create_database,
                is_active: $is_active,
                author_name: $author_name,
                icon_url: $icon_url,
                video_url: $video_url,
                github_repository: $github_repository,
                github_branch: $github_branch,
                variables: $variables[0],
                required_files: $required_files[0]
              }' > payload.json
          fi
          
          # Clean up temp files
          rm -f variables.json required_files.json
          
          echo "âœ… API payload created successfully"
      
      - name: Update template via API
        run: |
          echo "ðŸš€ Request Details:"
          echo "URL: ${{ inputs.api_base_url }}/api/application/templates/${{ inputs.template_id }}"
          echo "Method: PATCH"
          echo "Headers: Authorization: Bearer [HIDDEN], Content-Type: application/json, Accept: application/vnd.pterodactyl.v1+json"
          echo "Payload file: payload.json"
          echo ""
          
          # Show payload size for debugging
          echo "ðŸ“‹ Payload size: $(wc -c < payload.json) bytes"
          echo ""
          
          # Make the API request with PATCH
          RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}\n" \
            -X PATCH \
            -H "Authorization: Bearer ${{ secrets.api_bearer_token }}" \
            -H "Content-Type: application/json" \
            -H "Accept: application/vnd.pterodactyl.v1+json" \
            --data-binary @payload.json \
            "${{ inputs.api_base_url }}/api/application/templates/${{ inputs.template_id }}")
          
          # Extract HTTP status and body
          HTTP_BODY=$(echo "$RESPONSE" | sed '$d')
          HTTP_STATUS=$(echo "$RESPONSE" | tail -n1 | sed 's/HTTP_STATUS://')
          
          echo "ðŸ“Š API Response:"
          echo "Status: $HTTP_STATUS"
          echo "Body:"
          echo "$HTTP_BODY"
          echo ""
          
          # Check success (2xx status codes)
          if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
            echo "âœ… Template updated successfully!"
            if command -v jq >/dev/null 2>&1; then
              echo "$HTTP_BODY" | jq '.' 2>/dev/null || echo "$HTTP_BODY"
            fi
          else
            echo "âŒ Template update failed with status $HTTP_STATUS"
            echo ""
            echo "ðŸ” Troubleshooting:"
            case "$HTTP_STATUS" in
              401) echo "â€¢ Check if API Bearer Token secret is set correctly" ;;
              403) echo "â€¢ Check if the token has permission to update templates" ;;
              404) echo "â€¢ Check if TEMPLATE_ID (${{ inputs.template_id }}) exists" ;;
              422) echo "â€¢ Check payload validation - see error details below" ;;
              500) echo "â€¢ Server error - check API server logs" ;;
              *) echo "â€¢ Unexpected error code" ;;
            esac
            echo ""
            echo "ðŸ“‹ Error Details:"
            if command -v jq >/dev/null 2>&1; then
              echo "$HTTP_BODY" | jq '.' 2>/dev/null || echo "$HTTP_BODY"
            else
              echo "$HTTP_BODY"
            fi
            exit 1
          fi